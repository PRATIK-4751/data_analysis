╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 1: LOAD THE DATA                                             ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Get data into pandas for analysis.

✅ Code:
    import pandas as pd
    df = pd.read_csv('airline-passengers.csv')  # or from URL

📌 Key Tips:
    • Always use .head() to check: df.head()
    • Confirm the date column exists and is readable
    • Use raw GitHub URLs:
        url = 'https://raw.githubusercontent.com/.../airline-passengers.csv'

⚠️ Warning:
    Never assume the data is clean — always inspect first!

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 2: CONVERT TO DATETIME & SET INDEX                           ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Enable time-based operations (slicing, resampling, rolling).

✅ Code:
    df['Month'] = pd.to_datetime(df['Month'])
    df.set_index('Month', inplace=True)

📌 Key Tips:
    • This is NON-NEGOTIABLE for time series
    • Without it, you can't do df['2020'] or df.resample()

💡 Pro Tip:
    Always check: type(df.index) → should be DatetimeIndex

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 3: SET FREQUENCY (CRITICAL!)                                  ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Enable partial string indexing and resampling.

✅ Code (Best Practice):
    df.index = pd.date_range(start='1949-01-01', periods=len(df), freq='MS')

📌 Why?
    • 'MS' = Month Start (e.g., 1949-01-01)
    • Without freq, df['1950'] fails

❌ Don't Rely On:
    df.index.freq = 'MS'  # May not work!

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 4: INSPECT THE DATA                                          ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Check data quality before analysis.

✅ Code:
    df.info()
    df.isnull().sum()
    print("Start:", df.index.min())
    print("End:", df.index.max())
    print("Total rows:", len(df))

📌 Key Questions:
    • Are there missing values?
    • Is the date range correct?
    • Is the index a DatetimeIndex?

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 5: PLOT THE TIME SERIES                                      ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Visualize trend, seasonality, and volatility.

✅ Code:
    import matplotlib.pyplot as plt
    df.plot(figsize=(12,6), color='blue', linewidth=2)
    plt.title("Airline Passengers")
    plt.ylabel("Passengers")
    plt.xlabel("Year")
    plt.grid(True, alpha=0.5)
    plt.tight_layout()
    plt.show()

📌 What to Look For:
    • Upward trend? ✅
    • Seasonal peaks every year? ✅
    • Increasing volatility? ✅

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 6: SLICE BY DATE                                             ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Zoom in on specific periods.

✅ Code:
    df['1950']                    # Full year
    df['1955':]                   # From 1955 onward
    df['1950-06':'1950-09']       # June to September

📌 Key Rule:
    Only works if index is DatetimeIndex + frequency set.

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 7: EXTRACT DATE COMPONENTS                                   ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Group by month, year, etc.

✅ Code:
    df['Year'] = df.index.year
    df['MonthName'] = df.index.month_name()

📌 Use For:
    • df.groupby('MonthName')['Passengers'].mean()
    • Find which month has highest average

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 8: PLOT SEASONAL PATTERN (BAR CHART)                          ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Visualize average passengers by month.

✅ Code:
    monthly_avg = df.groupby('MonthName')['Passengers'].mean()
    month_order = ['January', 'February', ..., 'December']
    monthly_avg = monthly_avg.reindex(month_order)
    monthly_avg.plot(kind='bar', color='skyblue', edgecolor='navy')
    plt.title("Average Passengers by Month")
    plt.ylabel("Average Passengers")
    plt.xticks(rotation=45)
    plt.show()

📌 Insight:
    • July & August = peak travel
    • November & February = low season

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 9: RESAMPLE (Downsampling)                                    ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: See long-term trend by reducing frequency.

✅ Code:
    yearly_avg = df['Passengers'].resample('Y').mean()
    yearly_avg.plot(kind='line', marker='o')
    plt.title("Yearly Average")
    plt.show()

📌 Frequency Codes:
    • 'Y' = Yearly
    • 'M' = Monthly (end)
    • 'MS' = Month Start

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 10: ROLLING MEAN (Moving Average)                             ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Smooth data to reveal trend without downsampling.

✅ Code:
    df['Rolling_Mean'] = df['Passengers'].rolling(window=12).mean()
    df[['Passengers', 'Rolling_Mean']].plot()
    plt.title("Original vs 12-Month Rolling Mean")
    plt.show()

📌 Tip:
    • First (window-1) values = NaN
    • Great for visualizing trend

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 11: ROLLING STD (Volatility)                                 ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Measure how much prices fluctuate over time.

✅ Code:
    df['Rolling_Std'] = df['Passengers'].rolling(window=12).std()
    df['Rolling_Std'].plot(color='purple')
    plt.title("Rolling Standard Deviation")
    plt.show()

📌 Insight:
    • Rising std = increasing volatility
    • Common in multiplicative seasonality

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 12: EXPANDING MEAN (Cumulative Average)                       ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: See how average changes over time with new data.

✅ Code:
    df['Expanding_Mean'] = df['Passengers'].expanding().mean()
    df[['Passengers', 'Expanding_Mean']].plot()
    plt.title("Expanding Mean (Real-Time Trend)")
    plt.show()

📌 Use Case:
    • Forecasting with only past data
    • Simulates live decision-making

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 13: DECOMPOSE TIME SERIES                                    ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Split into Trend + Seasonal + Residual.

✅ Code:
    from statsmodels.tsa.seasonal import seasonal_decompose
    result = seasonal_decompose(df['Passengers'], model='multiplicative', period=12)
    result.plot()
    plt.show()

📌 Components:
    • Observed = Original
    • Trend = Long-term movement
    • Seasonal = Repeating pattern
    • Residual = Noise

📌 Use 'multiplicative' if swings grow with trend.

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 14: FINANCIAL TIME SERIES (Mercari Stock)                     ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Apply skills to real stock data.

✅ Code:
    import yfinance as yf
    mercari = yf.download('4385.T', start='2018-01-01', end='2023-12-31')
    mercari = mercari[['Close']]  # Keep only closing price

📌 Key: Always use .squeeze() if needed to avoid 2D issues.

────────────────────────────────────────────────────────────────────────

╔════════════════════════════════════════════════════════════════════════╗
║ 🔹 STEP 15: GOLDEN & DEATH CROSS                                     ║
╚════════════════════════════════════════════════════════════════════════╝
💡 Purpose: Detect bullish/bearish trend reversals.

✅ Code:
    mercari['MA50'] = mercari['Close'].rolling(50).mean()
    mercari['MA200'] = mercari['Close'].rolling(200).mean()

    # Golden Cross: MA50 crosses above MA200
    mercari['Golden'] = (mercari['MA50'] > mercari['MA200']) & (mercari['MA50'].shift(1) <=